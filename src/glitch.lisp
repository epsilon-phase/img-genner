(in-package :img-genner)

(defun compare-colors-bytewise(c1 c2)
;  (declare (type (vector (unsigned-byte 8) 3) c1 c2))
  (loop for a across c1
        for b across c2
        until (not (= a b))
        finally (return (< a b)))
  )
(defun compare-colors-magnitude(c1 c2)
  (declare (type (vector unsigned-byte *) c1 c2))
  (< (reduce #'+ c1) (reduce #'+ c2)))
(defun split-n-length(input l)
  "split a sequence into segments of at most l elements"
  (let ((len (length input)))
    (loop for start = 0 then (+ start l)
          for end = (min len (+ start l)) then (min len (+ start l))
          collect (subseq input start end)
          until (= end len)
          )
    ))
(assert (equal (split-n-length '(1 2 3 4 5 6 7) 2)
               '((1 2) (3 4) (5 6) (7))))
(defun sort-along-line(image line &optional (comparison #'compare-colors-bytewise))
  (declare (optimize (speed 2))
           (type (simple-array unsigned-byte (* * *)) image)
           (type vector line)
           (type (function (vector vector) boolean) comparison)
           )
  (let ((comb-length (length line))
        (sorted nil)
        (shrink 1.3))
    (loop for gap fixnum = comb-length then (floor gap shrink)
          when (<= gap 1)
            do(setf gap 1
                    sorted t)
          do(loop for i = 0 then (1+ i)
                  for j = (+ i gap) then (1+ j)
                  while (< (+ i gap) comb-length)
                  for (ax . ay) = (aref line i) then (aref line i)
                  for (bx . by) = (aref line j) then (aref line j)
                  when (funcall comparison (get-pixel image ax ay) (get-pixel image bx by))
                    do(progn (swap-pixel image ax ay bx by)
                             (setf sorted nil))
                  )
          while (not sorted)
          )
    )
  )
(defun ordinal-pixel-sort(image &key (comparison #'compare-colors-bytewise)
                                  (segment-length 20) (direction :left))
  (flet ((line (start)
           "start is the x or y coordinate to use"
           (multiple-value-bind (offset-x offset-y start-x start-y)
               (ecase direction
                 (:left (values -1 0 (1- (array-dimension image 1)) start))
                 (:right (values 1 0 0 start))
                 (:up (values 0 1 start 0))
                 (:down (values 0 -1 start (1- (array-dimension image 0))))
                 )
             (loop with r = (make-array 100 :adjustable t :fill-pointer 0)
                   for x = start-x then (+ x offset-x)
                   for y = start-y then (+ y offset-y)
                   while (and (>= x 0) (< x (array-dimension image 1))
                              (>= y 0) (< y (array-dimension image 0)))
                   do(vector-push-extend (cons x y) r)
                   finally (return r)
                   )
             )))
    (loop for i from 0 below (array-dimension image (ecase direction (:up 1) (:down 1) (:left 0) (:right 0)))
          do(loop for l in (split-n-length (line i) segment-length)
                  do(sort-along-line image l comparison))
          )
  ))
(export '(compare-colors-bytewise sort-along-line compare-colors-magnitude ordinal-pixel-sort))
