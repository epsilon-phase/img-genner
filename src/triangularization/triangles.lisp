(in-package img-genner/triangularization)
(defun clockwisep(polygon)
  (let ((points (coerce polygon 'vector)))
    (> 0
       (loop for i from 0 to (1- (length points))
             for j from 1 to (length points)
             summing (* (- (aref (svref points j) 0) (aref (svref points i) 0))
                        (- (aref (svref points j) 1) (aref (svref points i) 1)))
             ))))
(defun convexp(a b c)
  (> (triangle-sum (aref a 0) (aref a 1)
                   (aref b 0) (aref b 1)
                   (aref c 0) (aref c 1)) 0))
(defun triangle-sum (x1 y1 x2 y2 x3 y3)
  (+ (* x1 (- y3 y2))
     (* x2 (- y1 y3))
     (* x3 (- y2 y1))))
(defun triangle-area(x1 y1 x2 y2 x3 y3)
  (abs (/ (triangle-sum x1 y1 x2 y2 x3 y3) 2.0)))
(defun point-insidep(p a b c)
  (flet ((triangle-area (a b c)
           (triangle-area
            (aref a 0) (aref a 1)
            (aref b 0) (aref b 1)
            (aref c 0) (aref c 1)
            )))
    (let ((area (triangle-area a b c))
          (area1 (triangle-area p b c))
          (area2 (triangle-area p a c))
          (area3 (triangle-area p a b)))
      (> (sqrt single-float-epsilon)
         (abs (- area (+ area1 area2 area3)))))))
(defun contains-no-points(a b c polygon)
  (loop for i in polygon
        never (and (not (or  (equal a i)
                             (equal b i)
                             (equal c i)))
                   (point-insidep i a b c))))
(defun is-earp(a b c polygon)
  (and (contains-no-points a b c polygon)
       (convexp a b c)
       (> (triangle-area (aref a 0) (aref a 1)
                         (aref b 0) (aref b 1)
                         (aref c 0) (aref c 1))
          0.0)))
(defun earclip(polygon)
  (let ((polygon (coerce polygon 'vector))
        (ear-vertices nil)
        (point-count (length polygon))
        (triangles nil))
    (when (clockwisep polygon)
      (nreverse polygon))
    (loop for i from 0 to (1- (length polygon))
          for prev-index = (mod -1 point-count) then (mod (1+ prev-index) point-count)
          for next-index = 1 then (mod (1+ next-index) point-count)
          when (is-earp (svref polygon prev-index)
                        (svref polygon i)
                        (svref polygon next-index))
            do(push (list (svref polygon i)
                          (svref polygon prev-index)
                          (svref polygon next-index))
                    ear-vertices))
    (loop while (and ear-vertices (> point-count 3))
          for (ear prev next) = (pop ear-vertices) then (pop ear-vertices)
          with ear-index =(position ear polygon :test #'equal)
          do(setf ear-index (position ear polygon :test #'equal))
          do (delete ear polygon :test #'equal)
          do(push (list prev ear next) triangles)
          do(decf point-count)
          when (> point-count 3)
            do(let* ((prev-prev-index (mod (- ear-index 2) point-count))
                     (next-next-index (mod (+ ear-index 2) point-count))
                     (prev-prev-point (aref polygon prev-prev-index))
                     (next-next-point (aref polygon next-next index)))
                
                )
          )
    ))
